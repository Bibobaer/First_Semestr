Задание.

Объявить сущность типа Student (структуру struct Student), содержащую данные поля: 
	Имя (char*);
	Фамилия (char*);
	Дата рождения (хранить в целочисленном типе time_t);
	Дата поступления (time_t);
	Дата планируемого выпуска (time_t);
	Текущее состояние обучение студента (3 варианта: обучается, отчислен, выпустился) (unsigned int)

Реализовать интерфейс (меню) для работы со списком студентов. 
(!!!ПОД СПИСКОМ В ДАННОМ ЗАДАНИИ ПОНИМАЕТСЯ ДИНАМИЧЕСКИЙ МАССИВ СТРУКТУР!!!).
Список студентов должен быть представлен в виде динамческого двумерного массива (массива указателей на struct Student, оканчивающийся нулевым указателем, как признак конца списка).

struct Student** mainList									+---------->******************
		|													|			* struct Student *	
		|													|			*		...		 *
		+-------------->*****************************		|			******************
						* struct Student* pStudent1 *-------+			
						*---------------------------*					
						* struct Student* pStudent2 *------------------>******************
						*---------------------------*					* struct Student *
						*			...				*					*		...		 *
						*---------------------------*					******************
						* struct Student* pStudentN *-------+
						*---------------------------*		|					...
						*			NULL			*		|
						*****************************		+---------->******************
																		* struct Student *
																		*		...		 *
																		******************
																		
Адрес начала списка (переменная типа struct Student**) должна быть глобальной и изначально проинициализирована NULL.
На старте программы должна быть выделена память под список (только под один элемент - признак конца списка (под нулевой указатель)).

!!!ВАЖНО!!! 
	При добавлении нового элемента в список и удалении элемента, должно происходить перевыделение памяти (realloc). Т.е. перевыделение памяти под массив указателей.
	Не позволяется использовать статические массивы - всю память под массивы выделять в динамической памяти и соответственно правильно и вовремя очищать память.


Базовое задание:
	
Реализовать меню с выводом возможных команд (Можно по номерам с их описанием).
Список поддерживаемых команд:
	- Вывод данных всех студентов.
	- Поиск и вывод данных всех найденных студентов в списке по дате рождения, по имени, по фамилии, по состоянию обучения.
	- Вывод данных конкретного студента (поиск по имени и фамилии одновременно).
	- Вывод в отсортированном виде по имени, по фамилии, по дате рождения, по дате поступления, по состоянию обучения.
	- Добавление нового студента.
	- Изменение данных существующего студента (поиск по имени и фамилии одновременно).
	- Изменение состояния обучения конкретного студента. (состояние вводится в строковом виде: "Studying", "Graduated", "Expelled"). 
	- Удаление конкретного студента из списка (поиск по имени и фамилии одновременно).
		(Сделать отдельную команду "Отчислить").
	- Очистка всего списка.
	- Команда выхода из программы.
	
После исполнения той или иной команды, программа не должна завершаться, а снова запрашивать команду, при этом очищая предыдущий вывод.
(циклическое меню).

Реализовать следующие функции для работы со списком студентов:
	- Создание объекта типа Student:
		void* CreateObject(unsigned int sizeOfObjectInBytes);
		
		Данная функция выделяет память в динамической области памяти размером sizeOfObjectInBytes и заполняет нулями все содержимое данной выделенной памяти, затем возвращает адрес выделенной области. 
		Обратите внимание, что данная функция не зависит от типа объекта для которой выделяется память.
		
		Пример вызова:
			struct Student* newStudent = (struct Student*)CreateObject(sizeof(struct Student));
			
	- Инициализация полей объекта типа Student:
		void InitStudent(struct Student* pStudent, char* firstName, char* secondName, struct tm* pDoB /*Date of Birth*/, struct tm* pDoA /*Date of Admission*/, struct tm* pDoG /*Date of Graduate*/, int state);
		
		Замечание: структура tm и функции работы с ней изучить здесь https://cplusplus.com/reference/ctime/tm/
		
	- Добавление уже созданного и проинициализированного объекта в список структур:
		struct Student** AddStudent(struct Student** pStudentsList, struct Student* pNewStudent);
		Функция должна возвращать адрес добавленного элемента в массиве указателей на структуры при успешном добавлении или NULL в случае ошибки.
		
	- Удаление конкретного объекта из списка:
		int DeleteStudent(...);
			В ней реализовываете поиск студента, затем вызываете DeleteStudentFromList, затем очищаете память, выделенную под структуру Student.
		void DeleteStudentFromList(struct Student** pStudentsList, struct Student** pTargetStudent);
			DeleteStudentFromList - принимает указатель на сам список первым аргументом, вторым принимает адрес в массиве указателей на элемент, который нужно "убрать" из списка. При удалении элемента из массива указателей (в каком месте бы не был данный элемент) необходимо уменьшать (перевыделять) занимаемую память и смещать все элементы, которые располагались ниже текущего.
		
	- Поиск объекта в списка по имени, фамилии, дате рождения. Соответственно, реализовать три функции поиска по данным полям:
		struct Student** FindStudentBy____(struct Student** pStudentsList, ... /*подставить нужный тип и имя агрумента*/)
		Пример: 
			struct Student** FindStudentByName(struct Student** pStudentsList, char* name);
		Функции должны возвращать адрес найденного элемента в массиве указателей на структуры при успехе или NULL в случае неуспеха.
	
	- Реализовать функцию изменения "состояния" объекта (сменить можно строго на одно из трех вариантов - делать соответсвующие проверки).
		int ChangeState(struct Student* pStudent, int newState);
			Функция возвращает 1 в случае успеха (представим, что это булевое значение TRUE) и 0 в случае нуспеха (FALSE).
		
	- Реализовать функцию вывода списка студентов. Выводить все поля в таком формате:
		"Имя"
		"Фамилия"
		ДР	(в формате ДД.ММ.ГГГГ)
		ДП	(в формате ДД.ММ.ГГГГ)
		Состояние обучения	(в строковом виде: "Studying", "Graduated", "Expelled")
		Пример:
			"Ivan"
			"Ivanov"
			22.11.2000
			30.08.2023
			"Studying"
	
	- Реализовать функции добавления нового "Судента" из файла и с консоли. 
		int AddStudentFromConsole(struct Student** pStudentsList);
			Функция возвращает 1 в случае успеха (представим, что это булевое значение TRUE) и 0 в случае нуспеха (FALSE).
		int AddStudentFromFile(student Student** pStudentsList, const char* filePath);
			Функция возвращает 1 в случае успеха (представим, что это булевое значение TRUE) и 0 в случае нуспеха (FALSE).
		
		Данные должны вводится в данном формате:
			"Имя"
			"Фамилия"
			ДР	(в формате ДД.ММ.ГГГГ)
			ДП	(в формате ДД.ММ.ГГГГ)
			Состояние обучения	(в строковом виде: "Studying", "Graduated", "Expelled")
		При чтении из файла, данные должны быть записаны в таком же формате.
		Пример:
			"Ivan"
			"Ivanov"
			22.11.2000
			30.08.2023
			"Studying"
		Даты выпуска программа расчитывает самостоятельно, учитывая, что учиться необходимо 5,5 лет. 
		Обратите внимание, что хранить даты нужно в целочисленном типе time_t. Про перевод из структуры tm в time_t читать здесь https://cplusplus.com/reference/ctime/tm/
	
	- И прочие вспомогательные функции по своему усмотрению.


(35 баллов).


Дополнительные задания:

Команды для программы вводятся не номерами, а строковыми командами-запросами cо своим синтаксисом. 
Пример:
	Пример синтаксиса команды добавления студента:
	add FristName SecondName DoB DoA [DoG] state
	(В моем примере квадратные скобки означают необязательные параметры)
	Пример ввода данной команды:
	add Ivan Ivanov 22.11.2000 30.08.2023 Studying

Разработать свой синтаксис и свои параметры для каждой команды программы. Правильно обрабатывать все команды-запросы (выводить ошибки ввода и подсказывать пользователю в чем он был неправ).

(до 7 баллов). (Чем проще реализация и чем меньше проверок ввода - тем меньше баллов).


Реализовать систему бэкапов списка студентов (база данных), которая выгружается в файл и может быть загружена программой из файла.
	Придумать свой формат хранения в файле бэкапа. (чем меньше будет занимать места на диске - тем лучше).
		- Добавить возможность передавать путь до файла с существуюшим бэкапом при запуске программы в качестве аргумента командной строки. При этом программа на старте своей работы сразу считывает данные из бэкапа и инициализирует список оттуда. Далее программа считает этот файл "бэкапом по-умолчанию" и при завершении работы выгружает текущий список в этот бэкап. Если переданного файла не существует сообщать об этом пользователю и давать ему выбор: создать новый файл-бэкап либо игнорировать бэкап - аналогичный выбор при отсутствии аргумента программы.
		- Добавить команду backup в основное меню, которая будет "бэкапить" список либо в указанный этой команде файл-бэкап, либо в файл по-умолчанию.
	(до 10 баллов). (Оценивается так: чем оптимизированнее будет реализовано и чем "красиивее" будет написанный код - тем больше баллов).
		- Добавить команду "соединения" нескольких бэкапов (неограниченное количество) в один.
	(1 балл)
		* - Реализовать функционал периодического бэкапа самой программой в фоновом режиме. Для этого самостоятельно изучить способы написания многопоточных приложений под Windows. https://learn.microsoft.com/ru-ru/windows/win32/procthread/creating-threads - Использование WinAPI функций.
		Таким образом, вам нужно будет создать параллельный поток, код в котором будет с определенной периодичностью "бэкапить" список в файл. (Нужно также продумать синхронизацию данной возможности, т.к. из-за того, что основной поток и поток для бэкапа будут исполняться одновременно, может произойти коллизия данных - в основном потоке данные начнут меняться, а в бэкапе сохраняться "поврежденные", измененные неполностью данные).
	(до 5 баллов). (Зависит от использования инструментов синхронизации).


* В структуру добавить еще одно поле - хэш от двух соединенных строк с именем и фамилией, таким образом, у вас будет однозначное соотношение имени и фамилии с конкретным элементом списка, что упростит поиск элемента в списке, т.к. искать нужно будет по одному целочисленному полю, а не сравнивать строки.
	https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F - хэш-функции
	
	(Можно реализовать лубую хэш-функцию на ваш выбор).

При сдаче данного задания необходимо будет объяснить алгоритм хэширования, который вы используете.	

(до 5 баллов)


* - Задания, в которых необходимо самостоятельно изучить материал.

30.11.23